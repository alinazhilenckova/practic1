class BinaryTreeNode : 	def__init__(self, data) : 	self.data = data 	self.left = None 	self.right = None 	class BinaryTree : 	def insert(self, root, data) : 	if root is None : return BinaryTreeNode(data)  if data < root.data : 	root.left = self.insert(root, left, data) 	elif data > root.data : 	root.right = self insert(root, left, data)  	return root  	class TreeNode : 	def __init__(self, data) : 	self.data = data 	self.left = None 	self.right = None 	class BinaryTree : 	def __init__(self, root_data) : 	self.root = TreeNode(root_data) 	def insert_left(self, current_node, data) : 	if current_node.left is None : current_node.left = TreeNode(data) 	else : 		new_node = TreeNode(data) 		new_node.left = current_node.left 		current_node.left = new_node 		def insert_right(self, current_node, data) : 		if current_node.right is None : current_node.right = TreeNode(data) 		else : 			new_node = TreeNode(data) 			new_node.right = current_node.right 			current_node.right = new_node 			def in_order_traversal(self, node) : 			if node is not None : 				self.in_order_traversal(node.left) 				print(node.data) 				self.in_order_traversal(node.right)    				class BinaryTree : 				def deleteNode(self, root, data) : 				if root is None : return root  if data ‹ root.data : 	root.left = self.deleteNode(root.left, data) 	elif data › root.data : 	root.right = self.deleteNode(root.right, data) else: if root.left is None and root.right is None : return None elif root.left is None : return root.right elif root.right is None : return root.left else: root.data = self - getMin(root.right).data root.right = self.deleteNode(root.right, root.data)  return root  def getMin(self, root) : 	if root is None : return root  while root.left is not None : 	root = root.left  	return root     